package com.WiltonZhan.leetcode.l632SmallestRangeCoveringElementsFromLists;

import java.util.*;

/*
632. 最小区间
你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。

我们定义如果 b-a < d-c 或者在 b-a == d-c 时 a < c，则区间 [a,b] 比 [c,d] 小。

示例 1:

输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
输出: [20,24]
解释:
列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。
列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。
列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。
注意:

给定的列表可能包含重复元素，所以在这里升序表示 >= 。
1 <= k <= 3500
-10^5 <= 元素的值 <= 10^5
对于使用Java的用户，请注意传入类型已修改为List<List<Integer>>。重置代码模板后可以看到这项改动。
 */
public class Solution {
    /**
     * 将k个升序排列的整数数组合并成一个数组，同时记录每个数字所对应的组。随后在组上进行滑窗，在保证窗口内包含所有组的同时计算最小区间。
     * 例如：[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]合并后得到：
     * [(0,1),(4,0),(5,2),(9,1),(10,0),(12,1),(15,0),(18,2),(20,1),(22,2),(24,0),(26,0),(30,2)]
     * 如果只看组号的话，排列为：
     * [1,0,2,1,0,1,0,2,1,2,0,0,2]
     * 在保证窗口内包含所有分组号的前提下进行滑窗：
     * [1,0,2],1,0,1,0,2,1,2,0,0,2 -> [0,5]
     * 1,[0,2,1],0,1,0,2,1,2,0,0,2 -> [4,9] > [0,5] -> [0,5]
     * 1,0,[2,1,0],1,0,2,1,2,0,0,2 -> [5,10] > [0,5] -> [0,5]
     * 1,0,[2,1,0,1],0,2,1,2,0,0,2 -> [5,12] > [0,5] -> [0,5]
     * 1,0,[2,1,0,1,0],2,1,2,0,0,2 -> [5,15] > [0,5] -> [0,5]
     * 1,0,2,1,0,[1,0,2],1,2,0,0,2 -> [12,18] > [0,5] -> [0,5]
     * 1,0,2,1,0,1,[0,2,1],2,0,0,2 -> [15,20] > [0,5] -> [0,5]
     * 1,0,2,1,0,1,[0,2,1,2],0,0,2 -> [15,22] > [0,5] -> [0,5]
     * 1,0,2,1,0,1,0,2,[1,2,0],0,2 -> [20,24] < [0,5] -> [20,24]
     * 1,0,2,1,0,1,0,2,[1,2,0,0],2 -> [20,24] < [0,5] -> [20,24]
     * 1,0,2,1,0,1,0,2,[1,2,0,0,2] -> [20,24] < [0,5] -> [20,24]
     */
    public int[] smallestRange(List<List<Integer>> nums) {
        if (nums == null || nums.size() == 0) {
            return null;
        }

        // 计算总长度
        int len = 0;
        for (List<Integer> integers: nums) {
            len += integers.size();
        }

        // 合并各数组
        int idx = 0;
        int k = nums.size();
        int[][] pairs = new int[len][2];
        for (int i = 0; i < k; i++) {
            for (int num: nums.get(i)) {
                pairs[idx][0] = num;
                pairs[idx][1] = i;
                idx++;
            }
        }
        Arrays.sort(pairs, Comparator.comparingInt(o -> o[0]));

        // 计算最小区间
        int left = pairs[0][0], right = pairs[len - 1][0];
        int[] counts = new int[k];
        int t = 0;
        int j = 0;
        for (int i = 0; i < len; i++) {
            if (counts[pairs[i][1]] == 0) {
                t++;
            }
            counts[pairs[i][1]]++;

            if (t == k) {
                while (counts[pairs[j][1]] > 1) {
                    counts[pairs[j][1]]--;
                    j++;
                }
                if ((left == 0 && right == 0) || (right - left > pairs[i][0] - pairs[j][0])) {
                    left = pairs[j][0];
                    right = pairs[i][0];
                }
            }
        }

        return new int[]{left, right};
    }
}
